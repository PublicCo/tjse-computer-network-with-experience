## 传输层

在网络层之上

* 提供进程之间的逻辑通信（对进程看传输抽象，他们好像在端到端地通信）
* 多路复用（就是所有人可以用相同的协议），分用：接收方在传输层时根据报头可以找到接收的应用
* 对报文首部和数据进行差错检测（校验位）
* 包括了TCP和UDP

端口：标注了是哪个进程进行通信（类似主机之间的ip地址）

* 是软件端口（port），不是插座的端口
* 端口号唯一标识进程（65536个），仅仅对本机有意义。服务端大多数应用会使用0-1023端口，其他端口（1024-49151）是特殊应用程序用的。客户端用（49152-65535）端口，只在进程需要的时候动态选择，不会长时间占用
* “端到端”就是进程到进程

套接字

* 其实就是（主机ip，端口号）
* 唯一标识网络中某个主机上的某个应用
* 因此网络通信过程中，有一个源端口号和一个目的端口号，唯一指定了通信的两方。报文中包含的目的端口号和源端口号就是这个

TCP/IP：实现两个传输协议：

* TCP：实现全双工的逻辑信道。传输前必须先发报文建立连接，结束后释放连接
  * 不广播或组播，只点到点
  * TCP来进行流量控制，确认，是否超时，连接是否中断

* UDP：无连接非可靠传输层协议。仅仅在IP传输中确保将读取的包给到确定的应用以及确保包的正确性检验
  * 快，实时性好，但是丢包就没办法了。适合小文件传输和实时传输
* TCP需要20B的首部，但UDP只要8B

UDP 数据包：

* 16位的源端口
* 16位目的端口
* 16位UDP长度（首部和数据）
* 16位校验和

## 重新开始

传输层：用于提供逻辑通信。虽然网络层有一定的保证，但是传输层进一步提高

* 稳定
* 流量控制
* 拥塞控制

## TCP

1. 准确性

   TCP准确性依赖ACK，超时机制，校验码

2. 传输头：![image-20240105203418468](C:\Users\leon\AppData\Roaming\Typora\typora-user-images\image-20240105203418468.png)

   窗口：记录接收区的窗口buffer

   数据偏移：：header长度

* 三次握手（目的，打开全双工通道）
  * SYN：seq=x
  * SYN ACK：seq=y,ack=x+1
  * ACK: seq=x+1,ack = y+1
* 几种错误：
  * duplicate SYN：无论如何，被动开启方都会返回一个SYN ACK。由于SYN ACK的ack部分在主动开启方已经发送过了，这是主动发起方会发起一个RST重置关闭这个通道
  * 同时发起SYN：双方在接收到SYN的时候进入SYN-receive状态，然后向对方发起SYN ACK，一旦双方都接收到SYN ACK就进入establish，且双向发送接收（各自的一次SYN ACK相当于打开一边通道）
* 四次挥手：
  * FIN：seq=u(倒数第二帧的号)
  * （FIN）ACK：seq=v（当前帧的下一帧）,ack = u+1
  * FIN,ACK:seq=w（最后一帧帧号）,ack=u+1（记录之前发的ACK）
  * ACK : seq=u+1（最后一帧的号）,ack = w+1
  * 最后主动关闭方要等2MSL（两倍segment生存的最久时间，避免发送方还未关闭）
* 几种错误
  * 同时关闭：相当于各自FIN，ACK。因此双方对对方发出FIN，然后等对方接收ACK
* 重传
  * 超时：很容易理解，设置的时间上限比RTT稍微大一点，如果超时了就重新发送一次。TCP通常会动态调整上限，一般是算平均RTT
  * duplicate ACK：多次接收到ACK就说明对方一直没接收到，此时需要重传对方的ACK
* 总结：
  * 没有上下文信息的时候，ack为空，seq为当前帧（上一帧的下一帧（雾））。有上下文信息的时候ack是对面发过来的序号+1（相当于我已经接收到这一帧了等下一帧）

## 拥塞控制

rwnd：就是接收者的buffer，接收窗口

cwnd：传输者的拥塞窗口，根据算法来估计网络拥塞程度，控制传播分组数量

算法：AIMD（additive increase,multiplicative decrease)

* 在TCP包里打包了接收方的rwnd窗口，因此发送方选择rwnd和cwnd中较小的一部分
* RTT的估计维护方法：用EWMA（Exponential Weighted Moving Average)来估计。可以让RTT更smooth。估计方式是R(new) = (1-x)R(old)+x(SampleRTT)，其中x通常为0.125.这样随时间变化RTT变得不大，但是确实能够通过SampleRTT来估计RTT
* 维护方法：纯种慢启动（TCP Tahoe）（ssthresh: slow start threshold)
  * 当3次ACK同一个包时认为timeout
  * 最原始的方法，只有慢开始，初始cwnd为1
    * 慢开始的时候指数增长cwnd，直到到达一个限制的ssthresh值。然后线性增长，直到遇到超时。此时重新慢开始，并将ssthresh值设为上次cwnd大小的一半
    * 注意，指数增长的最后一步是min(cwnd*2,ssthresh)，不能乘2后跳过ssthresh
  * 快速重传：要求传输基本是正确的才能快速重传（Reno算法）
    * 对于三次ACK，认为问题不大，因此将CWND下降到一半，然后线性增加
    * 对于没有ACK的timeout，还是下降到1 慢重启

## 公平性

要求所有接入的设备在基本占用总带宽的前提下每个人分到的带宽基本相同

## 套接字

* 在Server建立的时候，首先为开放的端口create socket，并且设置ip和端口。服务器随时监听该socket
* 然后client首先随机选择端口和ip建立socket
* 然后发送connect请求，三次挥手后建立
* 然后write一个数据请求发送给服务器
* 服务器先read请求，准备好了数据就write返回
* 关闭的时候四次挥手