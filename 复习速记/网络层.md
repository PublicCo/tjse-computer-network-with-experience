## 介绍

* 目的是如何给自己adressing，以及其他人怎么routing，同时也有congestion control
* 虚电路
  * 传输前每个路由先建立起虚电路，相当与每个节点之间先接线（逻辑）
  * 完成连接后每个节点会确定传输的包应该往哪条“电线”发
    * 对于一个包来说，首先包自己有一个初始的VC号。
    * 节点根据这个包的VC号，再根据建立虚电路时记录的字典找到下一步节点传输的节点和传输的新的VC号
    * 虚电路拆除直接删掉in和out的VC号映射关系就可以了
  * 一般用在ATM（Asyn Transfer Mode,异步传输）和MPLS（MultiProtocol Label Switching)
  * 只有相邻节点信息
* datagram network
  * 每个路由器都维护一个路由表，记录到某个节点下一步转发的节点时什么
  * 如果到一个节点有多种转发方式，通过最长前缀进行匹配
  * 拥有全局路由信息

## IP

* 可以修改，不像MAC唯一标识
* 必须是single identify的
* IPv4头示例如下
  * Version：用IP几的协议（这里是4）
  * Hdr Len：头部有多长
  * TOS：用的是什么服务，一般是0
  * Total Length：加上头部整个帧有多长
  * Identification：计数器，每产生一个数据包加一
  * Flag：比如标志最低位记录后面还有没有分片，最后一个frame是0否则是1
  * Fragment Offset：记录该片是在总分组里第几个
  * TTL：活了多久，每过一个路由-1，到0就丢
  * Protocol：记录用什么协议传输（TCP，UDP）
  * Header Checksum：首部校验和
  * 后面就是望文生义了

![image-20240105133610632](C:\Users\leon\AppData\Roaming\Typora\typora-user-images\image-20240105133610632.png)

* 一些地址
  * A类：1-126，只有前八位是网络，后面是主机
  * B类：128-191，前16位是网络，后面是主机
  * C类：192-223：前24位是网络，后面是主机
  * D类：224-239：多播
  * 127.0.0.0：归主机自己用
  * 剩下的：以后用
* 特殊地址
  * 192.168.1.0代表网络本身
  * 192.168.1.255代表网络广播地址
  * 0.0.0.0代表本网络中本主机，语义由网络自己决定
  * 255.255.255.255代表向所有使用IP协议的网络广播。由于路由器的限制，其实就是向本网络的所有主机广播

* 可用地址信息如下：（对于host，0和255不能用）

  ![image-20240105135708343](C:\Users\leon\AppData\Roaming\Typora\typora-user-images\image-20240105135708343.png)

* 但现在ipv4不够用了
  * 网络规模很大，路由表太大了：通过子网来解决
  * B类地址不够了：用几个C类合成一个B类来解决
* subnet address：B类不够了，想想办法！
  * 首先前16位还是B类地址的网络
  * 16-24是subnet id，用来分配B类中的一些id的
  * 24-32用来规定主机
  * 于是有了子网掩码的说法
    * network mask：255.255.0.0,用来找到总网络
    * subnet mask:255.255.255.0,找到子网
    * 寻找的方式就是拿IP和子网掩码进行与操作，获得的IP后面跟0，意味着向该网络广播
  * 当然，如果路由表里能直接匹配指定地址优先转发到指定地址
* Supernetting：想办法用几个连续的C类网合成一个B类网
  * 通过将网络地址的位数控制在24以内，这样就可以扩大主机地址个数了
    * 如192.168.14.123/22，意思是只有前22位是网络地址，后面都是主机地址
    * 因此每一位可以扩大2^n^个地址，只要确保全1和全0的地址依旧空出来，其他的主机地址随便用
  * 当然，另一种方式是用Mask来控制，255.255.252.0等价于192.168.14.123/22中22
  * 在匹配的过程中，会选择最长前缀（即属于网络地址最多的）的路由进行转发
  * 匹配方式就是先用mask和ip进行and操作，结果和指定路由地址进行比较，相同就转发

* 接下来需要解决网络规模问题。网络规模过大容易导致路由表膨胀，因此采用default route来处理那些路由表没记录的IP。这样路由表可以只记录小部分IP，剩下的丢给默认的下一个路由器让它解决,用0.0.0.0来记录这种未记录的IP
* 一些IP 差错控制协议
  * ICMP（Internet Control Message Protocol）：如果传输过程中报文出错了，那么就向源主机返回一些报文通知这些状态
    * 终点不可达
    * 源点抑制
    * 超时
    * 参数有误
    * 路由应重定向
  * ARP与RARP（Address Resolution Protocol):用来解决IP与MAC的映射。
    * 首先A向本局域网中所有主机广播自己的IP与MAC码，然后问指定的某个ip（如192.168.1.3）的MAC码是什么？
    * 拥有这个IP的主机收到后将自己的IP与MAC码发送给A，其他人不响应
    * 这些信息写入ARP表方便后续使用
    * 如果是广播IP为192.168.1.1这种，路由器会回应，传输后剩下由路由器来解决

## 路由算法

* dijstra算法：要求要对整个网络拓扑的传输速度都清楚，找到最短的路由路径

  * 首先知道起始节点A放入Set N，然后从A开始检查所有A可以连通的节点，记录长度并进队列。
  * 每次从栈里拿出当前Set N里的元素能到达的最短路径的节点B，放入Set N，按顺序更新所有节点信息检查有没有更短的路径
  * 所有的节点都出栈（都遍历了），算法结束
  * 主要的问题在于网络传输速率会震荡，需要更新每个信道的速率，且全局信息不容易得知

* Bellman-Ford算法：只需要知道周边的节点的信息。算法用于找到其他节点到达指定节点的最短路径

  * 首先为每个节点分配好更新的顺序

  * 然后按序更新每个节点（好的顺序可以少更新几次）

    * 对每个节点C，询问它周围的节点B，找到一条最短的从C到目标节点A的路径（C直接到A或者C到B集 里的某个节点再到A）

  * 不断更新直到某次更新不再变化

  * 对每个点都做一次，所以是n^3^的复杂度，所有信息都凑成一张表来记录要到每个节点下个节点往哪里传

  * 问题：good travel fast, bad travel slow（传输路径变快了所有人都很快知道，但传输路径变慢了很难到稳定状态，如果断开了会导致infinity loop）

    ![image-20240105163853177](C:\Users\leon\AppData\Roaming\Typora\typora-user-images\image-20240105163853177.png)

    * 数字代表hop次数。第一张图代表AB刚接入网络，B到A只需要跳一个router。四次更新后每个节点的网络表都到稳定状态。如果A到B更快了，那么也是四次循环回到稳定状态
    * 第二张图代表B到A突然断开了。B到A的距离变成inf。因此B必须更新自己的表。它发现C到A只需要2次（因为C还不知道没办法到A了），所以它的最短路径变成了B-C-A。
    * C发现B到A需要3跳了，但是它除了走B到A外别无选择，因此只能更新自己的次数：从C-B，再从B 跳三次到A。
    * 然后越来越大……如果B到A只是从1跳变成50跳，会一直循环到B发现直接到A比从C到A更快从而稳定下来。如果inf了那就无限循环了

* 层次路由

  * 路由表太大，需要一层层转发

  * 每一层可以有很多自治系统（AS，autonomous system），一个自治系统可以有很多局域网。自治系统内部的protocol可以不同，因此他们之间通信需要屏蔽区别

    * 内部网关协议：用于自治系统内部，一般用RIP，OSPF来处理

      * RIP（应用层协议，用udp转发）：小型网络用，传播路由最多15跳避免无限传播。

        * 每30秒每个节点向周围节点广播自己的路由表（节点地址和跳数）以自动维护路由表
        * 接收到别人的路由表时，首先将表中的下一跳改成接收路由表的源路由，然后跳数加一。如果当前路由表没有目的网络就加该项目；如果有且下一跳就是源目标X地址，用新的替换旧的；如果已经有目的网络但下一跳不是X，谁短选谁
        * 180秒内原来相邻的路由器不发消息了，认为该路由器不再可达

      * OSPF：网络层协议，在IP协议字段中为89

        1. 问候分组，检查分组节点可达性

        2. 数据库描述分组，请求对方发送记录链路状态的摘要信息

        3. 链路状态请求分组：请求对方发送一些链路的详细信息
        4. 链路状态更新分组：用flooding来向所有节点更新自己的状态
        5. 链路状态确认分组：对链路更新的确认
           * 建立的时候，先问候，再使用数据库描述分组进行同步。对于双方有一方不知道的链路信息用链路状态请求分组来更新自己的内容，更新包括请求-更新-确认
           * 当一个路由器链路发生变化后，用flooding广播自己的链路状态，其他路由器
           * 为了避免bad message goes slow，每一长段时间（半个小时）刷新链路状态

* 拥塞控制（通常让TCP来搞定）

  * AQM（Active Queue Management）
    * 发生拥塞丢弃最近传入的包
    * 随机选择丢包
    * ECN提前发现

* QoS（Quality of Service)

  * buffer满了如何选择谁先离开buffer？
  * FIFO
  * Priority Queuing
  * Round Robin Scheduler(时间片轮转)
  * Weighted Fair Queuing(WFQ,优先级时间片，耗时更长的后面)

* 流量控制

  * Leaky Bucket：全部装入一个buffer里，buffer慢慢流出流量。如果有很大的流量装满buffer，多出的直接溢出（底部漏洞的水桶
  * Token Bucket：往桶里放令牌，如果有人要传输，拿一个令牌走。没有令牌的就阻塞队列。如果没人来拿令牌，多出的令牌自动丢失（传输流量：消费者，令牌：生产者）

## BGP（Border Gateway Protocol）

每个AS选几个发言人，告诉周边的人可以通过自己到哪些自治系统以及内部节点

类似于RIP算法，不过一般来说节点数量少复杂度低