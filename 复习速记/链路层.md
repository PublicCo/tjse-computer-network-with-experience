## 这一层的作用

简单来说就是将物理层传输打包成一个协议来增加逻辑控制，确保正确传输比特流。

* 为网络层提供传输服务：有/无确认的无连接服务、有确认的连接服务
  * 无连接，无确认：逻辑上没有连接，接收后没有ack，没有丢帧的检测，适合一些稳定的传输链路（LAN）
  * 无连接，有确认：逻辑上没有连接，但包发送后可以收到ACK——因此有超时重传，适合不稳定的传输（WIFI，因为信号很容易断，每次重新建立连接开销很大）
  * 有连接，有确认：传输前先建立连接，且帧必须排好序。每个帧只能收到一次且必须按顺序收，
* 确保两端的节点有能力通信，且传输过程中维持连接不断
* 将网络层的分组设置为帧，添加一些信息来发送包（包括标志位界定帧，传输地址，校验位等）
* 控制帧传输，不要目标还没接收完帧就发下一帧，导致帧堆积过多丢失
* 设置ARQ校验错误

## 组帧

* 目的是将网络层提交的分组封装为帧，一部分一部分发出去
  1. 字符计数（character-based count)：在帧的开头记录帧长度。（即包括自己这一位在内有多少个位，注意是8比特一位），这样读多少bit后下一位就是下一帧的长度
     * 好处：帧的首位短
     * 坏处：一旦计数字符传输出错，整个传输过程全错
  2. 字符填充的首位定界(flag bytes with byte stuffing，注意byte=8bits)：通过设置一个特殊字符来确定帧的开头和结尾（比如ESC或DLE）。读到这个字符就知道到帧开头或结尾了
     * 如果帧内有这个ESC字符的话，那么就在帧中这个字符前插入一个ESC来代表转义。在读取的时候直接只读一个就行
     * 就是太麻烦了，这个字符也会占至少8bit
  3. 0比特首尾定界限（flag bytes with bit stuffing）：首先确定一个flag，比如01111110. 然后发送的时候为了避免传输flag，每读到5个1就加一个0.收方再实现每五个1去掉下一个0就可以了（只要保证0111110在传输过程是不存在的就行）

## 错误校验

* ECC：error control coding

* 分为error-detect code和error-correct code

* 几个定义

  * n-bit unit: 意思是m个data和r个校验冗余加起来（n=m+r)的一个检错单元
  * length of burst of error:连续的一段出错的长度
  * burst error detecting capability:这个code可以检测多少位的错误
  * the minimum distance of the code:至少翻转几位可以让这个算法检查不出错误
  * hamming distance:和上面那个意思一样，只不过不一定是最小的翻转次数。
    * 因此一般来说，最小海明距离就是最小翻转bit让检测机制检测不出错误

* 奇/偶校验码（只能detect不能recover）：

  * 最后一位保证1的个数是奇/偶数：如果1的个数是奇/偶数最后一位为0，否则为1
  * 最小海明距离：2
  * 进阶：2D奇偶校验：海明距离为3（翻转两个校验位加一个错误位），并且一个错误位可以被校验出来
  * 对于一个奇偶检验，检测d位错误必须是d+1 minimum hamming distance，恢复必须是2d+1hamming distance（两位确定一个位是不是报错）（一般来说，奇偶校验就是每一位校验多一海明距离。）

* 海明码（用1，2，4，8……2n位作为校验位）,可以detect和correct

  * 要求：n位unit要$$n\le2^r-1$$

  * 实现：对于m位，猜测最小的r满足上述式子。然后在1,2,4,8……2n位置上插入校验位。对于其他data在当前的位置上，检查它的二进制编码，对每一位进行奇偶校验

    >例：1011四位校验，首先设置为101?1??,然后处理如下
    >
    >011:1
    >
    >101:1
    >
    >110:0
    >
    >111:1
    >
    >接下来每个位上为1的都要参与异或
    >
    >位1：1\^1\^1=1
    >
    >位2：0
    >
    >位3：0，故应该位1010101
    >
    >检验的时候看每一位上哪几位是1，就选择哪几个校验位来判断，比如第七位是111，那么就用检验位1，位2，位3和被检验的一位异或来判断是不是0：1\^1\^1^'1'=0，说明没错。对其他位用相同的方式检验

  * 一位错校验，两位错检测（能校验就说明汉明距离至少为3）

* CRC校验：对于m位的data，发送器同时发送一个r位的帧检验序列（FCS）。现在的帧变成了m+r.然后确定一个首尾都是1的多项式G(x),用m+r的帧除G(x)(除法的每一步相减都是求异或，没有退位，或者说0被借位就变成1了)。如果能整除说明整个帧没问题。

  * FCS确定：记G（x）为t位，则r=t-1.因此首先在m位data后面补上r个0.然后对这个数对G（x）进行整除，求出的r位余数就是要在data后面补上的FCS。

    （比如对于gx=1101，data=101001，首先补充到101001000然后除gx，最后结果是001）

  * 能检测出r位错误

## ARQ（Automatic Repeat reQuest,自动重发）

* 自纠错开销大，所以采用接收检错-回应接收是否正确的机制，基于接收ACK-Retransmission的一套规则，
* ARQ首先有不同的帧，帧**有序号**，必须按顺序接收才可以。要ACK，必须接收到帧且帧没错。
* 最简单的：stop and wait
  * 发送方发一帧，等到收到了接收方的ack后再发第二帧。如果超时了就重发
  * 接收方如果收到了且数据没错，返回ACK，如果接收到但数据有错，返回NAK
  * 问题1：如果ACK传太久了导致超时重传，但是receiver不知道第二帧到底是超时重传还是下一帧（因为他也不知道ACK有没有传到）
    * 解决：每一帧都有一个seq number，这样就分别出了超时重传和连续传输的帧
  * 问题2：现在我们知道超时重传帧的分别了。但是如果帧0超时重传了两次且接收方收到两次，返回了两次ACK，只是太慢导致sender一直在超时重传。当sender读到第一次ACK的时候知道帧0发送成功了于是发送帧1.这时候他又读到了第二个ACK，没办法判断是第二次超时重传的帧0ack还是帧1的ack
    * 解决办法：ACK也上序号，每个seq frame都有一个对应的seq ACK
  * 有时候，AB需要相互传输。这个时候B传输给A的时候不仅可以传data，同时还可以传上一个包的ACK。只要确保ACK和当前帧都有序号，且序号一一对应即可
  * 在这个内容里，超时和NAK之间没有区别，因为都是等待对方的响应，对方没有响应或者返回NAK的时候就重传，否则就传下一帧
* 太慢了！整个RTT时间内都没有人在干活！等待的时候sender也得做事！：go back N Algorithm(或者说是sliding window protocols)
  * 假设接收方能接收10个帧的buffer，那么只要返回的ACK序号比当前传输包的序号小10以内，发送方就可以接着发，直到遇到超时或者NAK
  * 首先，我们优化了一点，现在不需要收到一个包就发回一个ACK了。receiver会返回当前正确接收包最大的序号。ACK-n代表第n-1个包已经正确发出了，等待第n个包的发送
  * 但错误的代价很大。
    * 假设发送者发送了0-9 十个包，第0个包超时了还没收到ACK，就需要重新再发送所有十个包
    * 假设某个包不对（比如第四个包吧），那么发送者就要从第四个包开始重传
  * 这是最基础的呢，对于两种丢包情况：
    * 现在第四个包传输过程中消失了，在接收者视角中frame从3跳到5了，这时候返回NAK4，那么直到重新获取到frame4之前，所有的frame都会被丢弃。sender也会在读取到NAK4的时候重新从4开始发送
    * 现在第四个包到手了，接收者返回ACK5.但是ACK5包丢了。由于ACK丢了，传输者等了很久都没有等到ACK，从0开始所有的包都要重传。但是对于已经传输的0-4的包属于duplicate error，接收方会自动丢弃
  * 总结一下：对于sender：超时就重传，NAK就重传到NAK的部分；对于receiver：如果传输的包内容错误或者包的序号错误，就发送NAK就行了，然后直到这个包正确收到前所有的包全部丢弃。另外，如果收到的包是错的且没收过，是discard as error,要立刻返回NAK。如果收到的包是错的且收到过，是discard as duplicate，丢掉重复的接着等就行
  * 记住，NAK是哪个包出错了，ACK-n是要第几个包（不是第几个包对了）
* 回退的代价太大了！有没有更精确的选择方法：选择重传协议（Selective Repeat,SR)
  * 原理就是如果某个包的ACK没收到（或者收到某个包的NAK了），那么就重传这个包
  * 这要求每个包都必须返回一次ACK，同时需要设计好的buffer使得部分丢失的帧重传前保留空位，不能被其他帧占了他的位置

## MAC（Medium Access Control): 介质访问子层

* 不同的连接方式

  * P2P：两个节点直接通信，没有中心服务器
  * Broadcast，向主线广播信号让另一方收。（无线局域网Wireless LAN使用802.11协议）

* 特殊的地址

  * 全0：unknown
  * 全1：广播
  * 组播：01-00-5E-xx-xx-xx(后面随意，前面必须是这个地址)

* 如果AC，BD传输需要经过主干道传输，但是主干道带宽比传输流量总和小。这时没有传输控制就会撞车导致两边都没法传输。因此使用MAC来使得两对节点通信不会干扰

* 一个办法是多路复用（分时间来传输时间片轮转（TDM，时分多路复用），将不同信号调制成不同频率，一个信号占一个频率然后把所有频率正交叠加起来（FDM，频分复用），用不同波长光信号传输（WDM，波分复用，特殊的时分复用），正交编码（CDM，码分复用

  但还是不够怎么办？

* 最狠的方法是给任意两个设备之间开专属信道（XDMA，Corss-Domain Direct Memory Access）,但是设备多了开销就大了（n方数量级信道）

* 因此我们需要用一些其他的方式来对信道的占用进行控制：信道利用率要最大化，且每个通信占用的带宽应该几乎平均的，并且减少collision（怎么减少）

  * 检测collision
  * 快速恢复collision

* 方法1：纯ALOHA（pure aloha）

  * 开摆，根本不解决这个问题，超时报错就是collision，传到接收到数据包的ACK为止。
  * 当然，由于探测collision就重传会让信道更加堵塞，每次探测到collision就等随机一段时间重传
  * 但其实传输节点一旦多起来，这个协议就会经常超时，超时就要等很久才能重传，因此这个网络吞吐量很低

* 方法2：时隙ALOHA（slotted aloha）

  * 将时间分为一个个时间片，要求每一时间片开始的时候才能传输。这样一旦两个数据存在碰撞，一发送就会碰撞而不会出现发送一半有人开始来了，从而降低碰撞概率（理论计算算出来确实降低了）
  * 但还是不好，碰撞就停这种暴力的方法显然有很大改进空间。怎么办？

* 方法3：CSMA（Carrier Sensing Multiple Access, 载波侦听多路访问）

  * 传输前检查信道有没有人在发送，有人在发就不发，空了才发。比起ALOHA，这样可以确保信道每时每刻都有人在传输
  * 有几种方法来设置传输：一空就传输，偶尔监听一下（等待随机时间监听）空就传输，监听到信道空闲的时候有p概率发送
  * 这种方法实现一半在有线LAN中，因为监听和传输时延性小。要求时延性小的原因如下
    * 如果时延性大，信道的一部分已经被某个帧占据了，但是一个节点由于延迟没有听到信道被占这个信号，那么节点就会直接开始传输，这样仍然会造成collision。同时由于两个frame在传输过程中都不会检测collision，那么直到传输结束的时间都会被浪费。
    * 因此，一个直观的解决方法就是传输过程中检测有没有collision，如果发生collision立刻停止传输清空信道。

* 方法4：CSMA/CD（CSMA/collision detect)

  * 传输过程中一直检测有没有collision。如果检测到了，立刻停下传输，等待随机时间再检查信道能不能传输
  * 适合有线局域网，因为有线才能实时用receiver监测接收当前信道传输的信息是自己的还是其他人的。
  * 最久检测时间就是B开始发的时候A信号到了。从A传输到A停手时间是一个RTT（A发到B的时候B开始发，B立刻停手，但B的信号需要半个RTT才能到A让A停手）

* 也可以设计出一套规则，符合这套规则运行的每个节点传输是不会collision的

  * 轮询，主机一个一个问谁要传
    * 开销很大，传输前都需要遍历一遍
    * 主机坏了就寄了
  * Token passing：谁拿到token谁传，传完给下一个
    * token坏了就寄了
    * 额外开销（要传token）
  * bitmap：
    * 首先轮询每个节点在某个时间点要不要发，谁要发谁就在时间点上标1
    * 如果这个时间点上标1（要发）的人不止一个，那就视为collision
    * 直到只有一个1才能发
  * binary countdown：每个人节点都有一个二进制计时器，从高位到地位比较，谁的值大谁先发

## 以太网

* **用的是IEEE802.3协议**，描述MAC和物理层的实现。

* Frame结构：![image-20240104213510219](C:\Users\leon\AppData\Roaming\Typora\typora-user-images\image-20240104213510219.png)

  8bit的帧分割码（前7位叫前同步,用来快速同步MAC帧的，最后一位是帧开始符号），6bit的目的MAC地址，6bit的源MAC地址.对于MAC，24高位归厂商，低位归自己，FCS封装帧尾部（虽然理论上不需要尾部，但在标准下用CRC来判断帧正确性，需要封装4位校验码），2bit类型指定处理的协议

* 最小46位，因为去掉前同步码后先后长18位，然后最小帧长必须达到64B，因此要有46位数据帧（不够就填满）。最大1500位（规定）
* 传输的间隔时长必须大于等于RTT（不然就没有分割意义了）
* 实际使用的CSMA/CD：
  * CSMA：检测到传输空了96 bit time（传96bit时间）就开始传。
  * CD：检测到collision就传一个特殊的jam signal（48 bits）来通知其他人
  * 随机时间退避：每有一次collision就将随机时间范围扩大至（0，2^m-1)。碰撞16次就直接不发了（说明太挤了）
* 拓扑结构：星形：![image-20240105082055442](C:\Users\leon\AppData\Roaming\Typora\typora-user-images\image-20240105082055442.png)
* hubs（集线器）：只是用来中转接收传输的数据，将从一个地方来的数据转发到所有端口上
  * 没有CSMA/CD，让连在它上面的其他机器自己想办法
  * 所有在hub上面的node都会collision，它自己是不设置zone来区分哪个node分在哪个zone里的
  * 作为物理层的一部分
  * 会出现广播风暴（每个传输的包都需要广播，很容易冲突）
* Switches：连接层的一部分。
  * 可以通过根据MAC addresses来发到指定几个端口上
  * 转发的时候有CSMA/CD来检测，同时交换机可以设置不同接口不同的zone
  * 可以自学习地建立不同路由之间的连接：
    * 从一个端口接收到信息，这个信息包括MAC地址，端口号和帧生存时间。交换机记录下来，如果下次有要传到这个MAC地址的包就从这个端口传输
    * 对于传输部分，如果目的端口被记录了且相同端口就直接drop the frame,如果不同端口就转发到端口。如果目的端口没被记录就将frame广播到每个端口（flood）

## WLAN：wireless lan，无线局域网

* **用的是802.11协议**
* 有几个特殊的要解决的东西
  * 传输过程信号衰减
  * 传输信号干扰
  * 可以通过不同节点传输：多径效应
* 隐藏节点问题：对于ABC三节点，AB和BC能够相互知道，但AC不知道，这样A和C传输给B的时候没办法通过CSMA/CD获得collision信息，进而在B处很容易collision
* 无线网也很难实时监听collision，因为监听与发送只能二选一
* 因此使用CSMA/CA来避免冲突
  * 核心思想是让每个人等待的空闲信道时间不同：对于一个机器等待不同时间，空闲的时候倒计时，拥塞的时候冻结倒计时。倒计时到了才让发送，如果还是collision那就进一步往后等
  * 对于有接入点的（AP mode）步骤如下
    * 首先A和B发一个很短的RTS信号给中央。虽然这个RTS也有可能collision，但是信息很短可以快速退避重发
    * 对于点A发送的RTS，接入点会广播CTS（A）通知周围所有人信道拥塞
    * A接收到CTS后开始传输。传输完中心点会广播一个ACK，其他人就可以重新传输RTS了